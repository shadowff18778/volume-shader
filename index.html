<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Kernel 3D Ultra Optimized</title>
    <style>
        body {
            background: #000;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none; 
            width: 100vw;
            height: 100vh;
        }

        #c1 {
            display: block;
            width: 100%;
            height: 100%;
        }

        #btn {
            position: fixed;
            left: 15px;
            top: 15px;
            z-index: 10;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            backdrop-filter: blur(10px);
            font-family: sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #config {
            position: fixed;
            left: 15px;
            top: 70px;
            display: none;
            background: rgba(20, 20, 25, 0.95);
            padding: 20px;
            border-radius: 15px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }

        textarea {
            font-family: 'Consolas', 'Monaco', monospace;
            width: 85vw;
            max-width: 400px;
            height: 200px;
            background: #000;
            color: #0f0;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            font-size: 13px;
            outline: none;
        }
        
        .controls {
            margin-top: 15px;
            display: flex; gap: 10px;
        }

        button.action {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: none;
            font-weight: bold;
            cursor: pointer;
        }

        #apply { background: #4caf50; color: white; }
        #cancle { background: #f44336; color: white; }
    </style>
</head>

<body>
    <canvas id="c1"></canvas>
    <button id="btn">CONFIG</button>
    <div id="config">
        <textarea id="kernel" spellcheck="false"></textarea>
        <div class="controls">
            <button id="apply" class="action">APPLIQUER</button>
            <button id="cancle" class="action">ANNULER</button>
        </div>
    </div>

    <script>
        "use strict";

        let canvas, gl;
        let cx, cy;
        let shaderProgram;
        let glLoc = {};
        
        // Optimisation DPR pour mobile
        const dpr = Math.min(window.devicePixelRatio, 1.5); 
        
        let mx = 0, my = 0, mx1 = 0, my1 = 0;
        let ml = 0, lastN = 0;
        let len = 2.5;
        let ang1 = 2.8, ang2 = 0.4;
        let targetAng1 = 2.8, targetAng2 = 0.4;
        let cenx = 0, ceny = 0, cenz = 0;

        let KERNEL = `float kernal(vec3 ver){
   float x = cos(1.0 / (ver.x*ver.x + 0.06));
   float y = cos(1.0 / (ver.y*ver.y + 0.06));
   float z = cos(1.0 / (ver.z*ver.z + 0.06));
   return -x-y-z-1.2;
}`;

        const VSHADER = `
            attribute vec4 position;
            varying vec3 vDir;
            uniform vec3 right, forward, up;
            uniform float aspectX, aspectY;
            void main() {
                gl_Position = position;
                vDir = forward + right * position.x * aspectX + up * position.y * aspectY;
            }`;

        const FSHADER_PREFIX = `
            precision highp float;
            uniform vec3 right, forward, up, origin;
            uniform float len;
            varying vec3 vDir;
            
            #define STEPS 100

            float kernal(vec3 ver);

            void main() {
                vec3 dir = normalize(vDir);
                vec3 p;
                float t = 0.01 * len;
                bool hit = false;

                for(int i = 0; i < STEPS; i++) {
                    p = origin + dir * t;
                    if(kernal(p) > 0.0) {
                        hit = true;
                        break;
                    }
                    t += 0.018 * len; // Step légèrement plus grand pour la perf
                    if(t > 4.5 * len) break;
                }

                vec3 color = vec3(0.01); // Fond presque noir
                if(hit) {
                    // Calcul des normales par échantillonnage
                    float e = t * 0.002;
                    vec3 n = normalize(vec3(
                        kernal(p - vec3(e, 0, 0)) - kernal(p + vec3(e, 0, 0)),
                        kernal(p - vec3(0, e, 0)) - kernal(p + vec3(0, e, 0)),
                        kernal(p - vec3(0, 0, e)) - kernal(p + vec3(0, 0, e))
                    ));
                    
                    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.4));
                    float diff = max(0.0, dot(n, lightDir));
                    vec3 baseCol = vec3(0.1, 0.7, 1.0);
                    color = baseCol * (diff + 0.15);
                    
                    // Speculaire
                    float spec = pow(max(0.0, dot(reflect(dir, n), lightDir)), 16.0);
                    color += spec * 0.5;
                }
                gl_FragColor = vec4(color, 1.0);
            }`;

        function initGL() {
            canvas = document.getElementById('c1');
            gl = canvas.getContext('webgl', { antialias: false, alpha: false });
            
            if (!gl) {
                console.error("WebGL non supporté");
                return;
            }

            resize();
            updateProgram(KERNEL);

            const buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, 1,1, -1,-1, 1,1, -1,1]), gl.STATIC_DRAW);
            
            setupInputListeners();
            requestAnimationFrame(render);
        }

        function updateProgram(kSrc) {
            const vs = compile(gl.VERTEX_SHADER, VSHADER);
            const fs = compile(gl.FRAGMENT_SHADER, FSHADER_PREFIX + kSrc);
            if(!vs || !fs) return;

            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) return;
            
            shaderProgram = prog;
            gl.useProgram(prog);

            glLoc = {
                pos: gl.getAttribLocation(prog, 'position'),
                right: gl.getUniformLocation(prog, 'right'),
                fwd: gl.getUniformLocation(prog, 'forward'),
                up: gl.getUniformLocation(prog, 'up'),
                orig: gl.getUniformLocation(prog, 'origin'),
                aspX: gl.getUniformLocation(prog, 'aspectX'),
                aspY: gl.getUniformLocation(prog, 'aspectY'),
                len: gl.getUniformLocation(prog, 'len')
            };

            gl.enableVertexAttribArray(glLoc.pos);
            gl.vertexAttribPointer(glLoc.pos, 2, gl.FLOAT, false, 0, 0);
        }

        function compile(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.log(gl.getShaderInfoLog(s));
                return null;
            }
            return s;
        }

        function resize() {
            if (!canvas || !gl) return;
            cx = window.innerWidth;
            cy = window.innerHeight;
            canvas.width = cx * dpr;
            canvas.height = cy * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function render(time) {
            if (!gl || !glLoc.orig) {
                requestAnimationFrame(render);
                return;
            }

            // Lissage des angles
            ang1 += (targetAng1 - ang1) * 0.1;
            ang2 += (targetAng2 - ang2) * 0.1;

            const x = Math.cos(ang1) * Math.cos(ang2);
            const y = Math.sin(ang2);
            const z = Math.sin(ang1) * Math.cos(ang2);

            // Nettoyage explicite du buffer
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.uniform1f(glLoc.aspX, cx * 2.0 / (cx + cy));
            gl.uniform1f(glLoc.aspY, cy * 2.0 / (cx + cy));
            gl.uniform1f(glLoc.len, len);
            gl.uniform3f(glLoc.orig, len * x + cenx, len * y + ceny, len * z + cenz);
            gl.uniform3f(glLoc.right, Math.sin(ang1), 0, -Math.cos(ang1));
            gl.uniform3f(glLoc.up, -Math.sin(ang2) * Math.cos(ang1), Math.cos(ang2), -Math.sin(ang2) * Math.sin(ang1));
            gl.uniform3f(glLoc.fwd, -x, -y, -z);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        function setupInputListeners() {
            window.addEventListener('resize', resize);
            
            canvas.addEventListener('mousedown', e => { ml = 1; mx = e.clientX; my = e.clientY; });
            window.addEventListener('mouseup', () => ml = 0);
            window.addEventListener('mousemove', e => {
                if(ml) {
                    targetAng1 += (e.clientX - mx) * 0.005;
                    targetAng2 += (e.clientY - my) * 0.005;
                    mx = e.clientX; my = e.clientY;
                }
            });

            // Correction pour les événements passifs sur mobile
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                len *= Math.exp(e.deltaY * 0.001);
            }, { passive: false });

            canvas.addEventListener('touchstart', e => {
                if(e.touches.length === 1) {
                    mx = e.touches[0].clientX; my = e.touches[0].clientY;
                } else if(e.touches.length === 2) {
                    mx = e.touches[0].clientX; my = e.touches[0].clientY;
                    mx1 = e.touches[1].clientX; my1 = e.touches[1].clientY;
                }
                lastN = e.touches.length;
            }, { passive: false });

            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if(e.touches.length === 1 && lastN === 1) {
                    targetAng1 += (e.touches[0].clientX - mx) * 0.005;
                    targetAng2 += (e.touches[0].clientY - my) * 0.005;
                    mx = e.touches[0].clientX; my = e.touches[0].clientY;
                } else if(e.touches.length === 2) {
                    let dx = e.touches[0].clientX - e.touches[1].clientX;
                    let dy = e.touches[0].clientY - e.touches[1].clientY;
                    let d = Math.sqrt(dx*dx + dy*dy);
                    let oldDx = mx - mx1;
                    let oldDy = my - my1;
                    let oldD = Math.sqrt(oldDx*oldDx + oldDy*oldDy);
                    if(oldD > 0) len *= (oldD / d);
                    mx = e.touches[0].clientX; my = e.touches[0].clientY;
                    mx1 = e.touches[1].clientX; my1 = e.touches[1].clientY;
                }
            }, { passive: false });
        }

        // UI
        document.getElementById("kernel").value = KERNEL;
        document.getElementById("btn").onclick = () => {
            const c = document.getElementById("config");
            const show = c.style.display === "none" || !c.style.display;
            c.style.display = show ? "block" : "none";
            document.getElementById("btn").innerText = show ? "MASQUER" : "CONFIG";
        };
        document.getElementById("apply").onclick = () => {
            const val = document.getElementById("kernel").value;
            updateProgram(val);
            KERNEL = val;
        };
        document.getElementById("cancle").onclick = () => {
            document.getElementById("kernel").value = KERNEL;
        };

        window.onload = initGL;
    </script>
</body>
</html>
